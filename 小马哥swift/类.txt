Swift也是一门面向对象开发的语言
class 类名 : SuperClass {
    // 定义属性和方法
}

定义的类,可以没有父类.那么该类是rootClass
通常情况下,定义类时.继承自NSObject(非OC的NSObject)

类的属性介绍
Swift中类的属性有多种
存储属性:存储实例的常量和变量
计算属性:通过某种方式计算出来的属性
类属性:与整个类自身相关的属性


存储属性
存储属性是最简单的属性，它作为类实例的一部分，用于存储常量和变量
可以给存储属性提供一个默认值，也可以在初始化方法中对其进行初始化
下面是存储属性的写法
age和name都是存储属性,用来记录该学生的年龄和姓名
chineseScore和mathScore也是存储属性,用来记录该学生的语文分数和数学分数
class Student : NSObject {
    // 定义属性
    // 存储属性
    var age : Int = 0
    var name : String?

    var chineseScore : Double = 0.0
    var mathScore : Double = 0.0
}

// 创建学生对象
let stu = Student()

// 给存储属性赋值
stu.age = 10
stu.name = "why"
stu.chineseScore = 89.0
stu.mathScore = 98.0


计算属性
计算属性并不存储实际的值，而是提供一个getter和一个可选的setter来间接获取和设置其它属性
如果只提供getter，而不提供setter，则该计算属性为只读属性,并且可以省略get{},直接写return XXX
下面是计算属性的写法
averageScore是计算属性,通过chineseScore和mathScore计算而来的属性
在setter方法中有一个newValue变量,是系统指定分配的
class Student : NSObject {
    // 定义属性
    // 存储属性
    var age : Int = 0

    //如果类型是结构体或者类，通常定义为可选类型
    var name : String?

    var chineseScore : Double = 0.0
    var mathScore : Double = 0.0

    // 计算属性
    var averageScore : Double {
        get {
            return (chineseScore + mathScore) / 2
        }

        //set可选 计算属性一般不写set
        // 赋值没有意义       newValue是系统分配的变量名,内部存储着新值
        set {
            self.averageScore = newValue
        }
    }
}

// 获取计算属性的值
print(stu.averageScore)


类属性(暂时了解)
类属性是与类相关联的，而不是与类的实例相关联
所有的类和实例都共有一份类属性.因此在某一处修改之后,该类属性就会被修改
类属性的设置和修改,需要通过类来完成
下面是类属性的写法
类属性使用static来修饰
courseCount是类属性,用来记录学生有多少门课程
class Student : NSObject {
    // 定义属性
    // 存储属性
    var age : Int = 0
    var name : String?

    var chineseScore : Double = 0.0
    var mathScore : Double = 0.0

    // 计算属性
    var averageScore : Double {
        get {
            return (chineseScore + mathScore) / 2
        }

        // 没有意义.newValue是系统分配的变量名,内部存储着新值
        set {
            self.averageScore = newValue
        }
    }

    // 类属性
    static var corseCount : Int = 0
}

// 设置类属性的值
Student.corseCount = 3
// 取出类属性的值
print(Student.corseCount)

----------------------------------监听属性的改变
在OC中我们可以重写set方法来监听属性的改变
Swift中可以通过属性观察者来监听和响应属性值的变化
通常是监听存储属性和类属性的改变.(对于计算属性，我们不需要定义属性观察者，因为我们可以在计算属性的setter中直接观察并响应这种值的变化)

我们通过设置以下观察方法来定义观察者
willSet：在属性值被存储之前设置。此时新属性值作为一个常量参数被传入。该参数名默认为newValue，我们可以自己定义该参数名
didSet：在新属性值被存储后立即调用。与willSet相同，此时传入的是属性的旧值，默认参数名为oldValue
willSet与didSet只有在属性第一次被设置时才会调用，在初始化时，不会去调用这些监听方法
监听的方式如下:
监听age和name的变化
class Person : NSObject {
    var name : String? {
        // 可以给newValue自定义名称
        willSet (new){ // 属性即将改变,还未改变时会调用的方法
            // 在该方法中有一个默认的系统属性newValue,用于存储新值
            print(name)
            print(new)
        }
        // 可以给oldValue自定义名称
        didSet (old) { // 属性值已经改变了,会调用的方法
            // 在该方法中有一个默认的系统属性oldValue,用于存储旧值
            print(name)
            print(old)
        }
    }
    var age : Int = 0
    var height : Double = 0.0
}

let p : Person = Person()

// 在赋值时,监听该属性的改变
// 在OC中是通过重写set方法
// 在swift中,可以给属性添加监听器
p.name = "why"

----------------------------------类的构造函数
构造函数类似于OC中的初始化方法:init方法
默认情况下创建一个类时,必然会调用一个构造函数
即便是没有编写任何构造函数，编译器也会提供一个默认的构造函数。
如果是继承自NSObject,可以对父类的构造函数进行重写

类的属性必须有值
如果不是在定义时初始化值,可以在构造函数中赋值
class Person: NSObject {
    var name : String
    var age : Int

    // 重写了NSObject(父类)的构造方法
    override init() {
    //可以不调用super.init()   没有主动调用，系统会默认调用
        name = ""
        age = 0
    }
}


我们在创建一个对象时就会给属性赋值
可以自定义构造函数
注意:如果自定义了构造函数,会覆盖init()方法.即不再有默认的构造函数
class Person: NSObject {
    var name : String
    var age : Int

    // 自定义构造函数,会覆盖init()函数
    init(name : String, age : Int) {
        self.name = name
        self.age = age
    }
}

// 创建一个Person对象
let p = Person(name: "why", age: 18)



字典转模型(初始化时传入字典)
真实创建对象时,更多的是将字典转成模型
注意:
去字典中取出的是NSObject,任意类型.
可以通过as!转成需要的类型,再赋值(不可以直接赋值)
class Person: NSObject {
    var name : String?
    var age : Int = 0

    // 自定义构造函数,会覆盖init()函数
    init(dict : [String : NSObject]) {
        name = dict["name"] as? String
        age = dict["age"] as! Int
    }
}

// 创建一个Person对象
let dict = ["name" : "why", "age" : 18]
let p = Person(dict: dict)



字典转模型(利用KVC转化)
利用KVC字典转模型会更加方便
注意:
KVC并不能保证会给所有的属性赋值
因此属性需要有默认值
基本数据类型默认值设置为0
对象或者结构体类型定义为可选类型即可(可选类型没有赋值前为nil)
class Person: NSObject {
    // 结构体或者类的类型,必须是可选类型.因为不能保证一定会赋值
    var name : String?

    // 基本数据类型不能是可选类型,否则KVC无法转化
    var age : Int = 0

    // 自定义构造函数,会覆盖init()函数
    init(dict : [String : NSObject]) {
        // 必须先初始化对象
        super.init()

        // 调用对象的KVC方法字典转模型
        setValuesForKeysWithDictionary(dict)
    }
}

// 创建一个Person对象
let dict = ["name" : "why", "age" : 18]
let p = Person(dict: dict)

----------------------------------方法重载
方法名字相同，参数不同

参数不同：
1.参数个数不同
2.参数类型不同