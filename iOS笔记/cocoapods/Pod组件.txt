gitignore.io:
https://www.toptal.com/developers/gitignore

sudo gem install cocoapods
gem list
sudo gem install cocoapods-acknowledgements
sudo gem uninstall cocoapods X.X.X

==================================================Podfile Syntax Reference
https://guides.cocoapods.org/syntax/podfile.html#post_install

==================================================含第三方库的组件
本地检测代码仓库是否有问题
pod lib lint xxx.podspec --allow-warnings --use-libraries

远程检测代码仓库是否有问题
pod spec lint xxx.podspec --allow-warnings --use-libraries

向远程代码索引库提交spec
pod trunk push xxx.podspec --allow-warnings --use-libraries

==================================================不含第三方库的组件
//本地检测代码仓库是否有问题
pod lib lint --allow-warnings --verbose

//远程检测代码仓库是否有问题
pod spec lint --allow-warnings --verbose

//向远程代码索引库提交spec
pod trunk push xxx.podspec --allow-warnings --verbose

==================================================私有库依赖私有库的
--allow-warnings //用它忽略警告
--verbose //打印执行过程详细信息
--use-libraries //表示使用静态库或者是framework，这里主要是解决当我们依赖一些framework库后校验提示找不到库的时候用到。
--sources=https://github.com/CocoaPods/Specs //如果库依赖了三方的pod库需要设置，可以设置私有库

验证远程spec文件是否有问题:
pod spec lint WYLoginModule.podspec --sources='https://gitee.com/BIMComponent/BIMRepo.git,https://github.com/CocoaPods/Specs.git' --allow-warnings --use-libraries 
pod spec lint xxx.podspec --sources ='repo1 url, repo2 url' --allow-warnings --use-libraries 

验证远程代码库:
pod lib lint WYLoginModule.podspec --sources='https://gitee.com/BIMComponent/BIMRepo.git,https://github.com/CocoaPods/Specs.git' --allow-warnings --use-libraries 
pod lib lint xxx.podspec --sources ='repo1 url, repo2 url' --allow-warnings --use-libraries

上传私有库:
1.   pod trunk me
看上传的私有库是否在列表中
如果不存在，就要在次上传此私有库
pod trunk push xxx.podspec --allow-warnings --use-libraries
上传本地:
pod repo push WYRepo WYLoginModule.podspec --sources='https://gitee.com/BIMComponent/BIMRepo.git,https://github.com/CocoaPods/Specs.git' --allow-warnings --use-libraries 
pod repo push XXXRepo xxx.podspec --sources ='repo1 url, repo2 url' --allow-warnings --use-libraries

上传完成之后:
rm ~/Library/Caches/CocoaPods/search_index.json
pod repo update

eg:
// podspec 设置依赖
s.dependency '私库'
s.dependency 'MBProgressHUD'
s.dependency 'Masonry'

// 本地校验
pod lib lint --verbose --use-libraries --allow-warnings
// 同时依赖私库和公共库，直接本地校验会出错，
 
// 校验podspec文件时会到远程podspec库查找相关依赖，默认只会到官方specs库校验，此时需要指定远程specs库去校验。----sources指定源
pod spec lint JKDJ_UIKit.podspec --verbose --use-libraries --allow-warnings --sources='https://私库.git,https://github.com/CocoaPods/Specs.git'

==================================================流程
pod lib lint -> git commit -> git push -> git tag -> git push --tag -> pod spec lint -> pod push

==================================================多target项目CocoaPods更新
在修改podfile并且pod install之后，复制的target会出现找不到头文件的情况
用abstract_target关键字添加一个不存在的target作为公用版，最下面增加项目中实际存在的target，表示共用上面的库
platform :ios, '8.0'

# Import CocoaPods sources
source 'https://github.com/CocoaPods/Specs.git'

abstract_target 'CommonPods' do

   pod 'AFNetworking'
   pod 'MJExtension'
   pod 'MJRefresh'
   pod 'SDWebImage'
   pod 'MBProgressHUD'
   pod 'IQKeyboardManager'
   pod 'Masonry'
   # 通讯录
   pod 'LJContactManager'
   # 选项卡
   pod 'BRPickerView'
   # 相机
   pod 'PureCamera'
   # 美洽客服
   pod 'Meiqia', '~> 3.4.3'
   # U-Share SDK UI模块（分享面板，建议添加）
   pod 'UMengUShare/UI'
   # 集成微信
   pod 'UMengUShare/Social/WeChat'
   # web 桥接
   pod 'WebViewJavascriptBridge', '~> 5.0'
   # 连连支付
   pod 'LLPay'
   # 极光
   pod 'JPush', '~> 3.0.6'
   
target 'jiebao'
target 'yingjidai'
target 'huawuque'
       
end
CommonPods是项目中不存在的自定义target名，最下面三个（jiebao、yingjidai、huawuque）是实际存在的target，
下面三个target共用了CommonPods中所有的三方库，每添加一个target再执行一遍pod install即可

==================================================cocoapods引入MJRefresh 
use_frameworks!的情况下: 
print(Bundle.main.bundlePath)
let bundle = Bundle(for: MJRefreshGifHeader.self)
print(bundle.bundlePath)

/Users/youdone-ndl/Library/Developer/CoreSimulator/Devices/B2F2E516-D85C-431B-B009-08ED2325EE37/data/Containers/Bundle/Application/4C1B2699-266B-4DB1-880C-48F225D20F67/TestGA.app
/Users/youdone-ndl/Library/Developer/CoreSimulator/Devices/B2F2E516-D85C-431B-B009-08ED2325EE37/data/Containers/Bundle/Application/4C1B2699-266B-4DB1-880C-48F225D20F67/TestGA.app/Frameworks/MJRefresh.framework


分别在app，framework（dynamic library），static lib中定义了三个类，并调用bundleForClass方法输出:
app -> app bundle
framework -> framework bundle
static lib -> app bundle

==================================================cocoapods
sudo gem install cocoapods
CocoaPods是专门为iOS工程提供第三方依赖库的管理工具
CocoaPods 通过一个名为 XXX.xcconfig 的文件来在编译时设置所有的依赖和参数。
CocoaPods是用 Ruby 写的

CocoaPod的核心组件:
CocoaPods/CocoaPod
这是一个面向用户的组件，每当执行一个 pod 命令时，这个组件都将被激活。该组件包括了所有使用 CocoaPods 涉及到的功能，并且还能通过调用所有其它的 gems 来执行任务。

CocoaPods/Core
Core 组件提供支持与 CocoaPods 相关文件的处理，文件主要是 Podfile 和 podspecs。
Podfile
Podfile 是一个文件，用于定义项目所需要使用的第三方库。该文件支持高度定制，你可以根据个人喜好对其做出定制。更多相关信息，请查阅 Podfile 指南。
Podspec
.podspec 也是一个文件，该文件描述了一个库是怎样被添加到工程中的。它支持的功能有：列出源文件、framework、编译选项和某个库所需要的依赖等。

CocoaPods/Xcodeproj
这个 gem 组件负责所有工程文件的整合。它能够创建并修改 .xcodeproj 和 .xcworkspace 文件。它也可以作为单独的一个 gem 包使用。如果你想要写一个脚本来方便地修改工程文件，那么可以使用这个 gem。

如何直接引用第三方库中的头文件？
在用CocoaPods集成第三方库之后，默认情况下，我们需要使用类似#import <XXX/YYY.h>的方式引入第三方库的头文件。
我们可以在Build Settings -> User Header Search Paths中添加${SRCROOT}并设置成recursive，这样我们就可以直接使用#impot "YYY.h"这种方式了。


==================================================cocoapods使用总结
https://guides.cocoapods.org/using/the-podfile.html

一个工程多个target引入CocoaPods的方式:
（推荐）方式一：通过abstract方式引入
#targetA: [AFNetworking,Masonry]
#targetB:[AFNetworking,SDWebImage]
abstract_target 'abstract_pod' do  #这里的abstract_pod在实际targets中不存在，是虚拟
    pod 'AFNetworking'
    
    target 'targetA' do
        pod 'Masonry'
    end
    
    target 'targetB' do
        pod 'SDWebImage'
    end
end

方式二：循环target 添加pod
#多个target的pod引入，方式一：如每个pod都引入masonry
targetArray = ['target1','target2']
targetArray.each do |t|
    target t do
        pod 'Masonry', '~> 1.1.0'
    end
end

方式三：提取公共pods 各个target引入
#多个target的pod引入，方式二：如每个pod都引入masonry
#添加索引库索引文件地址
source 'https://github.com/LGLee/MySpaces.git'
source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '9.0'

#多个target的pod引入
def commonPods
    pod 'Masonry', '~> 1.1.0'
end

#工程一：
target 'AnyDoorDemo' do
    commonPods
    pod 'AFNetworking', '~> 3.2.1'
    
    #测试相关↓
   target 'AnyDoorDemoTests' do
      inherit! :search_paths
      pod 'Specta', '~> 1.0.7'
      pod 'OCMock', '~> 3.4.2'
      pod 'Expecta', '~> 1.0.6'
   end

  target 'AnyDoorDemoUITests' do
    inherit! :search_paths
    # Pods for testing
  end
end

#工程二：
target 'HostApp' do
    commonPods
end


==================================================使用CocoaPods管理SDK
https://guides.cocoapods.org/making/making-a-cocoapod.html

删除仓库：
pod repo remove CodeBaseSpecs
更新仓库：
pod repo update CodeBaseSpecs

有时候当你使用pod update时会发现特别慢，那是因为pod会默认先更新一次podspec索引。使用--no-repo-update参数可以禁止其做索引更新操作。
pod update --no-repo-update

--verbose:
意思是打印详细信息

--only-errors和--allow-warnings:
--allow-warnings是允许warning的存在，也就是说当你在pod lib lint验证podspec的时候，如果不加这句，而你的代码里又一些警告的话，是验证不通过的。
而加上这句话的话，有警告也能验证通过。
--only-errors这句话是只显示出错误，就是你在验证的时候就算--allow-warnings，但是那些warnings也还是会打印出来和errors混杂在一起，
这会让你很难找error。所以这里使用--only-errors来只打印error，不打印warning

--fail-fast:
出现第一个错误的时候就停止

--use-libraries:
pod在提交或验证的时候如果用到的第三方中需要使用.a静态库文件的话，则会用到这个参数。如果不使用--use-libraries则会验证不通过。
但是比如你用swift创建了一个pod的话，你使用--use-libraries就会报错，因为swift开始，生成的就不是.a静态库了，它是不支持编译为静态库的，
只能生成.Framework动态库。下面就是swift的pod使用--use-libraries时的报错：
ERROR | [iOS] unknown: Encountered an unknown error (Pods written in Swift can only be integrated as frameworks; add use_frameworks! to your Podfile or target to opt into using it. The Swift Pod being used is: Socialite) during validation.

给Pod添加资源文件:
在 podspec 中，我们利用 s.source_files 来指定要编译的源代码文件。但是一些资源文件如图片、nib、plist等要怎么办呢？这里有两种方式：s.resources和s.resource_bundles。
s.resources和s.resource_bundles的区别主要是后者在上面代码[NSBundle bundleForClass:<#ClassFromPodspec#>]中得到的那个bundle对象下面再生成一个.bundle资源文件夹，
相较于s.resources直接平铺的方式更好的组织了文件，避免资源文件命名冲突。
s.resource_bundles = {
'PodTest'(.bundle文件名) => 'PodTest/Assets/*.{png,xib,plist}'
}
Podfile使用use_frameworks!
编译后资源文件会在test.app/Frameworks/PodName.framework下的PodTest.bundle目录下
NSBundle *bundle = [NSBundle bundleForClass:<#ClassFromPodspec#>];
[UIImage imageWithContentsOfFile:[bundle pathForResource:@"PodTest.bundle/imageName@2x" ofType:@"png"]];
Podfile不使用use_frameworks!
编译后资源文件会在test.app下的PodTest.bundle目录下
[UIImage imageNamed:@"PodTest.bundle/imageName"];
//下面这种也可以
NSBundle *bundle = [NSBundle bundleForClass:<#ClassFromPodspec#>];
[UIImage imageWithContentsOfFile:[bundle pathForResource:@"PodTest.bundle/imageName@2x" ofType:@"png"]];
使用s.resources方式
s.resources = ['PodTest/Assets/*.{png,xib,plist}']
注意切换resources和resource_bundles测试的时候要把工程clear一下，不然的话之前的位置那些编译过的资源文件还会存在。

初始化一个Podspec文件:
pod spec create MyTest

/**
 ###私有库###
 pod repo
 github创建私有Specs仓库 https://github.com/ndlwill/CodeBaseSpecs
 pod repo add CodeBaseSpecs https://github.com/ndlwill/CodeBaseSpecs
 github创建私有代码库仓库 https://github.com/ndlwill/ndl-ios-sdk
 pod lib create ndl-ios-sdk
 可以将多个XX.podspec和XX目录的源码全放在ndl-ios-sdk
 
 git init
 git add .
 git commit -m "提交描述"
 git remote add origin 远程私有库地址
 // 第一次push如果报错的话可以加上-f
 git push origin master
 git tag '0.1.0'
 git push --tags
 
 pod lib lint Utilities.podspec --private
 pod spec lint Utilities.podspec --private

 // 这个命令有两个作用：
第一：在本地repo/CodeBaseSpecs仓库添加我们的podspec文件
第二：在我们的远端存放podspec仓库里push最新的podspec文件
 pod repo push 索引库的本地名称 xx.podspec
 pod repo push CodeBaseSpecs Utilities.podspec

 pod spec相对于pod lib会更为精确，pod lib相当于只验证一个本地仓库，pod spec会同时验证本地仓库和远程仓库。

 source 官方索引库url
 source 私有索引库url
 pod '组件名称'
 pod install
 */

搜不到私有库？
pod repo update privateSpecs

==================================================私有库问题总结
1.关于第三方库支持 的cpu的框架
Undefined symbols for architecture i386:
ld: symbol(s) not found for architecture i386
cup的框架 : arm64 x86_64 armv7 armv7s i386
s.xcconfig = { 'VALID_ARCHS' => 'arm64 x86_64 armv7 armv7s' }

2.第三方含有 静态库(.a) 和 动态库(.framework)
///添加
s.static_framework = true

3.自己引进 静态库(.a) 和 动态库(.framework)
s.vendored_libraries  = 'UC_IM/Classes/Lib/*.{a}' /// 该目录下 .a
s.vendored_framework  = 'UC_IM/Classes/Framework/***.framework'  ///Framework目录下的***.framework动态库

4.私有库使用子模块
如果你想引用一个私有库里面的一小部分功能，但是又不想把整个库导入，那么私有库的子模块 ,外部单独依赖这个子模块

子模块的定义，也还是在.podspec文件中
#子模块 —— 头文件
s.subspec 'Header' do |ss|
   ss.source_files = 'UC_IM/Classes/Header/*.{h,m}'
end
使用子模块时只需在podfile中添加  pod 'UC_IM/header' 

5.使用私有库的分支和本地库
主工程podfile
pod 'Ucoupon',:git => 'http://git.hnbangyao.com/ios', :branch => 'dev' #直接使用远程库的branchName最新提交，而不是通过XXXRepo索引库中的tag标签
使用本地的仓库
pod 'Ucoupon',:path => '/Users/MacBook/Project/UC_IM' #直接使用本地库, '/Users/MacBook/Project/UC_IM' 是私有库在本地的目录，这种更方便于开发。

6.直接使用头文件 像PCH文件一样
s.prefix_header_contents = '#import <Masonry/Masonry.h>','#import "header.h"'

7.公共库需要多人操作
//添加管理者
pod trunk add-owner xxx_Mediator xxxxxxxxxxx@qq.com
//删除管理者
pod trunk remove-owner xxx_Mediator xxxxxxxxxxx@qq.com

8.私有库含有swift文件
验证私有库不能使用 --use-libraries  
不能使用静态库的验证

==================================================s.subspec
一般一个大的项目写成pod的时候，它可能会分为多个subspec，这样的话当你用一个庞大的库时，只需要其中的一小部分，那么就可以使用其中的某个subspec了。

我们拿AFNetworking.podspec来看，比如只引入其中的Reachability

pod 'AFNetworking/Reachability'
或者
pod 'AFNetworking',:subspecs=>['Reachability','Security']
所以一般subspec之间最好不要有互相依赖，不然的话，你用了其中一个subspec，而它其中一个文件依赖了另一个你未引入的subspec中的文件的话是会报错的。

如果有多个subspec互相依赖的话，可以像AFNetworking.podspec里这样写，UIKit依赖于NSURLSession
s.subspec 'NSURLSession' do |ss|
    //省略一大段代码
end

s.subspec 'UIKit' do |ss|
    ss.ios.deployment_target = '7.0'
    ss.tvos.deployment_target = '9.0'
    ss.dependency 'AFNetworking/NSURLSession'

    ss.public_header_files = 'UIKit+AFNetworking/*.h'
    ss.source_files = 'UIKit+AFNetworking'
end


PODS:
  - AFNetworking (3.0.0):
    - AFNetworking/NSURLSession (= 3.0.0)
    - AFNetworking/Reachability (= 3.0.0)
    - AFNetworking/Security (= 3.0.0)
    - AFNetworking/Serialization (= 3.0.0)
    - AFNetworking/UIKit (= 3.0.0)
  - AFNetworking/NSURLSession (3.0.0):
    - AFNetworking/Reachability
    - AFNetworking/Security
    - AFNetworking/Serialization
  - AFNetworking/Reachability (3.0.0)
  - AFNetworking/Security (3.0.0)
  - AFNetworking/Serialization (3.0.0)
  - AFNetworking/UIKit (3.0.0):
    - AFNetworking/NSURLSession
DEPENDENCIES:
  - AFNetworking (= 3.0)
SPEC CHECKSUMS:
  AFNetworking: 932ff751f9d6fb1dad0b3af58b7e3ffba0a4e7fd

PODFILE CHECKSUM: f38d14cf91adf9e2024f841ce5336dae96aa6fa6

COCOAPODS: 1.2.0.beta.1


#####s.subspec互相之间的依赖问题#####
当你把源码分为多个s.subspec的时候，其实是需要在对应的subspec下面做依赖的，如下面这样：
s.subspec 'ViewController' do |ss|
     ss.source_files = 'PodName/ViewController/*.{h,m}'
end

s.subspec 'View' do |ss|
     ss.source_files = 'PodName/View/*.{h,m}'
end
如上面这样写的话(ViewController中有文件依赖于View)，你在本地编译安装pod库其实是不会报错的。
但是如果你要pod spec lint的验证这个podspec，它会报错，提示'ViewController'中某个文件找不到引用View中的文件。
其实pod在做检查的时候会把ViewController和View当做两个独立的spec，如果ViewController中有使用View中的文件的话，需要添加依赖关系，如下这样就是正确的。
s.subspec 'ViewController' do |ss|
     ss.source_files = 'PodName/ViewController/*.{h,m}'
     ss.dependency 'PodName/View'
end

s.subspec 'View' do |ss|
     ss.source_files = 'PodName/View/*.{h,m}'
end

==================================================pod install和pod update的区别
源码:
https://github.com/CocoaPods/CocoaPods/blob/1.2.0.beta.1/lib/cocoapods/command/install.rb#L32
https://github.com/CocoaPods/CocoaPods/blob/1.2.0.beta.1/lib/cocoapods/command/update.rb#L47

//是否更新repo索引
install.rb默认不更新
update.rb默认更新
我们就常常会使用pod update --no-repo-update来禁止更新repo

update.rb 独有的，因为有个命令是更新某个特定的pod用的。pod update podName
pod update podName的时候会去Podfile.lock文件检查这个pod是否安装过，如果没有安装过会抛出异常
但是如果直接pod update的话就算Podfile.lock中没有某个pod，这是不会抛出异常，它会默认帮你先安装好，然后写入到Podfile.lock文件中。

//installer.update表示是否更新pod。
install.rb默认不更新
update.rb默认更新
pod update默认是更新pod的，而pod install是不更新的。
但是这是相对于pod 'SDWebImage', '~>3.8.0'这样的写法来用的。比如原来已经安装过3.8.0版本，Podfile.lock中就为3.8.0版本，满足~>3.8.0这个条件，那么pod install的时候是是不会更新到最新版的。
但是pod update会更新到最新版，同时改写Podfile.lock中的版本号为最新版。

而pod 'SDWebImage', '3.8.1'这种写法的话，pod install和pod update是一样的。比如Podfile.lock中原来为3.8.0版本，那么不管怎样都是不等于'3.8.1'的。
pod install的时候就会重新安装'3.8.1'版本，同时改写Podfile.lock中的版本号为'3.8.1'

https://guides.cocoapods.org/using/pod-install-vs-update.html
主要就是说pod install用在adding/removing pods的时候。而当你需要更新pods的时候使用pod update
还有最好把你的Podfile.lock文件提交到版本管理中，要不然，就会破坏整个逻辑，没有了Podfile.lock限制你的Pods中的库的版本。

==================================================第一次pod setup特别慢
利用shadowsocks的socks5代理，配置好后明显加速。用下面两条命令配置好后，保持shadowsocks客户端开启就行了。
//shadowsocks的本地端口默认是1080
git config --global http.proxy 'socks5://127.0.0.1:1080' 
git config --global https.proxy 'socks5://127.0.0.1:1080'
然后用下面这种直接clone的方式能够看到进度
cd ~/.cocoapods/repos
git clone https://github.com/CocoaPods/Specs.git

==================================================Podfile 语法
https://guides.cocoapods.org/syntax/podfile.html#podfile
https://guides.cocoapods.org/syntax/podfile.html#post_install

----------Podfile 的全局配置：
install!
CocoaPods 安装此 Podfile（也就是执行 pod install/update） 时，指定要使用的安装方法和选项。
第一个参数表示要使用的安装方法；下一个参数表示安装选项。
目前唯一可用的安装方法是 'cocoapods'，所以总要将其第一个参数。但未来版本中可能会提供更多的安装方法。

指定自定义的 CocoaPods 安装选项：
install! 'cocoapods',
         :deterministic_uuids => false,
         :integrate_targets => false

支持的命令：
:clean
:deduplicate_targets
:deterministic_uuids
:integrate_targets
:lock_pod_sources
:share_schemes_for_development_pods

----------依赖:
Podfile 会指定每个 target 的依赖关系。

pod:
pod 指定了项目的依赖关系，一般通过 Pod 库名称和可选的版本来定义。
若需要最新版本的 Pod 库，则只需要省略掉版本即可
= 0.1 0.1 版本。
> 0.1 高于 0.1 的任意版本。
>= 0.1 0.1 及更高版本。
< 0.1 低于 0.1 的任意版本。
<= 0.1 0.1 及更低版本。
~> 0.1.2 介于 0.1.2（包含）和 0.2（不包含） 之间的版本，同时会选择满足条件的最高版本。相当于满足 >= 0.1.2 且 < 0.2.0 条件的最高版本。

可以参考:
https://guides.rubygems.org/patterns/#semantic-versioning

构建配置:
默认情况下，target 的所有 build configuration 都会安装依赖。有时出于调试目的或其他原因，只能将依赖安装在部分 build configuration 中。
pod 'PonyDebugger', :configurations => ['Debug', 'Beta']
或者，也可以指定将其包含在单个 build configuration 中。
pod 'PonyDebugger', :configurations => 'Debug'
注意，依赖库是会传递的。有时候需要根据情况手动指定 build configurations。

Subspecs:
通过名字进行 Pod 安装时，会安装其 podspec 中指定的默认 subspecs。
可以通过以下方式安装 subspec：
pod 'QueryKit/Attribute'
也可以指定多个 subspec：
pod 'QueryKit', :subspecs => ['Attribute', 'QuerySet']
依赖也可以从外部指定。

使用本地路径的依赖:
如果项目和 Pod 库同时进行开发，则可以使用 path 选项。
pod 'AFNetworking', :path => '~/Documents/AFNetworking'
使用这个选项，CocoaPods 将把给定的目录作为 Pod 的根目录，并且会将其 Pods 项目中的文件关联起来。这样的话，每次编辑都会对 CocoaPods 产生影响。
请注意，目录中应该包含 Pod 库的 podspec 文件。

使用指定地址的 pod 库:
有时可能需要使用最新版本或特别修改过的 Pod。这种情况下，可以指定 pod 库的地址。
使用依赖库的 master 分支：
pod 'AFNetworking', :git => 'https://github.com/gowalla/AFNetworking.git'
使用依赖库的另一个分支：
pod 'AFNetworking', :git => 'https://github.com/gowalla/AFNetworking.git', :branch => 'dev'
使用 tag：
pod 'AFNetworking', :git => 'https://github.com/gowalla/AFNetworking.git', :tag => '0.7.0'
指定某次提交：
pod 'AFNetworking', :git => 'https://github.com/gowalla/AFNetworking.git', :commit => '082f8319af'
注意，这也要满足其他 Pod 库的依赖。

podspec 一般位于仓库的根目录中。如果仓库不包含 podspec 文件，就必须使用以下方法。
从外部获取 podspec:
可以考虑从外部获取 podspec，比如说通过 HTTP：
pod 'JSONKit', :podspec => 'https://example.com/JSONKit.podspec'

podspec:
如果没有指定 podspec 参数，则使用 Podfile 根目录中的第一个 podspec。

参数
options Hash {Symbol=>String}
加载 podspec 的路径。如果未提供，则使用 Podfile 目录中的第一个 podspec。

例如：
podspec
podspec :name => 'QuickDialog'
podspec :path => '/Documents/PrettyKit/PrettyKit.podspec'

target：
与 Xcode 的 target 对应，可以指定依赖的作用域。默认情况下，target 会包含外部定义的依赖，除非设置不要 inherit!。

参数
name Symbol, String
target 的名称

例如：
定义 target
target 'ZipApp' do
  pod 'SSZipArchive'
end

定义通过父级访问 SSZipArchive 的测试 target
target 'ZipApp' do
  pod 'SSZipArchive'

  target 'ZipAppTests' do
    inherit! :search_paths
    pod 'Nimble'
  end
end

父 target 的 Pods 应用于多个子 target：
target 'ShowsApp' do
  pod 'ShowsKit'

  # Has its own copy of ShowsKit + ShowTVAuth
  target 'ShowsTV' do
    pod 'ShowTVAuth'
  end

  # Has its own copy of Specta + Expecta
  # and has access to ShowsKit via the app
  # that the test target is bundled into

  target 'ShowsTests' do
    inherit! :search_paths
    pod 'Specta'
    pod 'Expecta'
  end
end

abstract_target:
定义一个新的抽象目标，它可以方便的用于目标依赖继承。

参数
name Symbol, String
target 的名称

定义抽象 target

abstract_target 'Networking' do
  pod 'AlamoFire'

  target 'Networking App 1'
  target 'Networking App 2'
end

定义包含多个 target 的 abstract_target
# 注意：workspace 的 Xcode 项目中并没有名为 "Shows" 的 target
abstract_target 'Shows' do
  pod 'ShowsKit'

  # ShowsiOS 包含 ShowsKit（继承）和添加的 ShowWebAuth
  target 'ShowsiOS' do
    pod 'ShowWebAuth'
  end

  # ShowsTV  包含 ShowsKit（继承）和添加的 ShowTVAuth
  target 'ShowsTV' do
    pod 'ShowTVAuth'
  end

  # ShowsTests 包含 Specta 和 Expecta，同时也作为 Shows 的子 target，引入了 ShowsKit
  target 'ShowsTests' do
    inherit! :search_paths
    pod 'Specta'
    pod 'Expecta'
  end
end

abstract!
表示当前目标是抽象的，因此不会直接链接到 Xcode 的 target。

inherit!
设置当前 target 的继承模式。

参数
inheritance Symbol
要设置的继承模式。
可用的模式：:complete target 继承父级的所有行为。:none target 不会继承父级的行为。:search_paths target 只继承父级的 search paths。

target 'App' do
  target 'AppTests' do
    inherit! :search_paths
  end
end

inherit! :search_paths
明确指定继承于父层的所有pod，默认就是继承的

----------Target configuration
这些设置用于控制 CocoaPods 生成的项目。

需要描述项目适用的 platform。xcodeproj 文件允许明确指定要链接的项目。

platform:
用于指定应建立的静态库的平台。如果不指定，则使用默认的配置

参数
name Symbol
平台名称，可以为，:osx，:ios，:tvos 以及 :watchos。
target String, Version
可选。不设置的话将使用默认配置。

指定平台
platform :ios, '4.0'
platform :ios

project:
默认情况下是没有指定的，当没有指定时，会使用Podfile目录下与target同名的工程
# JYCocoaPodsTest这个Target只有在JYCocoaPodsTest工程中才会链接
target 'JYCocoaPodsTest' do
project 'JYCocoaPodsTest'
...
end

###为 target 指定项目###

还可以指定是否这些设置在 release 或者 debug 模式下生效，参数为 :release 或 :debug。

参数
Path String
项目链接的路径
build_configurations Hash{String => symbol}
键值对。键为 Xcode 项目中的 build configurations 名称，值为基于 :debug 或 :release 配置的 Symbols。如果没有设置的话，默认为 :release。

指定用户项目
# FastGPS 项目中包含此 target
target 'MyGPSApp' do
  project 'FastGPS'
  ...
end

# 相同 Podfile 下，多个 Xcode 项目
target 'MyNotesApp' do
  project 'FastNotes'
  ...
end

使用自定义构建配置
project 'TestProject', 'Mac App Store' => :release, 'Test' => :debug

inhibit_all_warnings!
禁止来自 CocoaPods 库的所有警告。
该属性由子 target 定义继承。

如果每个 pod 库都想禁用警告，则可以使用：
pod 'SSZipArchive', :inhibit_warnings => true

此外，当使用 inhibit_all_warnings！ 属性时，也可以排除某个不禁用警告的库：
pod 'SSZipArchive', :inhibit_warnings => false

use_frameworks!
使用 frameworks 代替静态库。
该属性由子 target 定义继承。

----------Workspace
指定应该包含所有projects的Xcode workspace
如果没有显示指定workspace并且在Podfile所在目录只有一个project，那么project的名称会被用作于workspace的名称
如果没有指定明确的 Xcode workspace，并且 Podfile 同目录下只有一个项目，那么将使用该项目的名称作为 workspace 的名称。

参数
path String
workspace 的路径。

例如：
指定 workspace
workspace 'MyWorkspace'

----------Sources
用来指定 Pod 库的来源。Sources 是全局的，并且不由 target 自己定义。
源是顺序相关的。CocoaPods 将使用包含 Pod 的第一个源的 Pod 的最高版本（无视其他源是否有更高版本）。
官方的 CocoaPods 源是隐士包含的。一旦指定另一个来源，那么它将会包括在。

参数
source String
源地址

例如：
指定首先使用 Artsy 库，然后使用 CocoaPods 的 Master 库
source 'https://github.com/artsy/Specs.git'
source 'https://github.com/CocoaPods/Specs.git'

----------Hooks
Podfile 提供了可以在安装过程中调用的钩子。钩子是全局的，并且不由 target 自己定义。

plugin:
指定了安装期间应使用的插件，以及在调用时应该传递给插件的选项。

参数
name String
插件的名字
options Hash
钩子被调用时应该传递给插件的可选选项。

例如：
指定使用 slather 和 cocoapods-keys 插件。
plugin 'cocoapods-keys', :keyring => 'Eidolon'
plugin 'slather'

pre_install:
这个挂钩允许下载完成之后，但是在安装之前对 Pod 进行修改。
接受 Pod::Installer 作为唯一参数。

例如：
Podfile 中定义 pre-install 钩子
pre_install do |installer|
  # Do something fancy!
end

post_install:
允许生成的 Xcode 项目被写入磁盘之前进行最后的修改，或者执行其他的任务。
接受 Pod::Installer 作为唯一参数。

例如：
自定义所有 target 的构建设置
post_install do |installer|
  installer.pods_project.targets.each do |target|
    target.build_configurations.each do |config|
      config.build_settings['GCC_ENABLE_OBJC_GC'] = 'supported'
    end
  end
end


==========
target 'JYTest' do
pod 'JYPodTest', :path => '~/Desktop/JYPodTest'  # 指定路径
#pod 'JYPodTest', :podspec => '~/Desktop/JYPodTest/JYPodTest.podspec'  #指定podspec文件
end