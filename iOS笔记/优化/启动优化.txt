dyld:
dyld是苹果的动态链接器系统先读取App的可执行文件（Mach-O文件），从里面获得dyld的路径，然后加载dyld，dyld去初始化运行环境，
开启缓存策略，加载程序相关依赖库(其中也包含我们的可执行文件)，并对这些库进行链接，最后调用每个依赖库的初始化方法，在这一步，runtime被初始化。
当所有依赖库的初始化后，轮到最后一位(程序可执行文件)进行初始化，在这时runtime会对项目中所有类进行类结构初始化，然后调用所有的load方法。
最后dyld返回main函数地址，main函数被调用，我们便来到了熟悉的程序入口。

dyld共享库缓存:
当你构建一个真正的程序时，将会链接各种各样的库。它们又会依赖其他一些framework和动态库。需要加载的动态库会非常多。
而对于相互依赖的符号就更多了。可能将会有上千个符号需要解析处理，这将花费很长的时间
为了缩短这个处理过程所花费时间，OS X 和 iOS 上的动态链接器使用了共享缓存，OS X的共享缓存位于/private/var/db/dyld/，
iOS的则在/System/Library/Caches/com.apple.dyle/。
对于每一种架构，操作系统都有一个单独的文件，文件中包含了绝大多数的动态库，这些库都已经链接为一个文件，并且已经处理好了它们之间的符号关系。
当加载一个 Mach-O 文件 (一个可执行文件或者一个库) 时，动态链接器首先会检查共享缓存看看是否存在其中，如果存在，那么就直接从共享缓存中拿出来使用。
每一个进程都把这个共享缓存映射到了自己的地址空间中。这个方法大大优化了 OS X 和 iOS 上程序的启动时间。

dyld加载过程:
1、Load dylibs image
在每个动态库的加载过程中，dyld需要做下面工作：
分析动态库
找到动态库的mach-o文件
打开文件
验证文件
在系统核心注册文件签名
对动态库的每一个segment调用mmap()
针对这一步的优化：
减少非系统库的依赖
合并非系统库

项目依赖的共享动态库
输入命令：otool -L XXXX
2、Rebase/Bind image
由于ASLR(address space layout randomization)的存在，可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，
所以需要这2步来修复镜像中的资源指针，来指向正确的地址。
rebase修复的是指向当前镜像内部的资源指针； 而bind指向的是镜像外部的资源指针。

rebase步骤先进行，需要把镜像读入内存，并以page为单位进行加密验证，保证不会被篡改，所以这一步的瓶颈在IO。
bind在其后进行，由于要查询符号表，来指向跨镜像的资源，加上在rebase阶段，镜像已被读入和加密验证，所以这一步的瓶颈在于CPU计算。
优化该阶段的关键在于减少__DATA segment中的指针数量。我们可以优化的点有：
减少Objc类数量， 减少selector数量
减少C++虚函数数量
3、Objc setup
Objc setup主要是在objc_init完成的，objc_init是在libsystem中的一个initialize方法libsystem_initializer中初始化了libdispatch，
然后libdispatch_init调用了_os_object_int， 最终调用了_objc_init。
void _objc_init(void)
{
    static bool initialized = false;
    if (initialized) return;
    initialized = true;
    
    environ_init();
    tls_init();
    static_init();
    lock_init();
    exception_init();

    _dyld_objc_notify_register(&map_2_images, load_images, unmap_image);
}
通过上面代码可以知道，runtime在_objc_init向dyld绑定了3个回调函数，分别是map_2_images,load_images和unmap_image
(1)dyld在binding操作结束之后，会发出dyld_image_state_bound通知，然后与之绑定的回调函数map_2_images就会被调用，它主要做以下几件事来完成Objc Setup：
读取二进制文件的 DATA 段内容，找到与 objc 相关的信息
注册 Objc 类
确保 selector 的唯一性
读取 protocol 以及 category 的信息
(2)load_images函数作用就是调用Objc的load方法，它监听dyld_image_state_dependents_initialize通知
(3)unmap_image可以理解为map_2_images的逆向操作
由于之前2步骤的优化，这一步实际上没有什么可做的。几乎都靠 Rebasing 和 Binding 步骤中减少所需 fix-up 内容。因为前面的工作也会使得这步耗时减少。
4、initializers
以上三步属于静态调整，都是在修改__DATA segment中的内容，而这里则开始动态调整，开始在堆和栈中写入内容。 工作主要有：
(1)Objc的+load()函数
(2)C++的构造函数属性函数 形如attribute((constructor)) void DoSomeInitializationWork()
(3)非基本类型的C++静态全局变量的创建(通常是类或结构体)(non-trivial initializer) 比如一个全局静态结构体的构建，如果在构造函数中有繁重的工作，那么会拖慢启动速度

Objc的load函数和C++的静态构造器采用由底向上的方式执行，来保证每个执行的方法，都可以找到所依赖的动态库

(1)dyld开始将程序二进制文件初始化
(2)交由ImageLoader读取image，其中包含了我们的类、方法等各种符号
(3)由于runtime向dyld绑定了回调，当image加载到内存后，dyld会通知runtime进行处理
(4)runtime接手后调用map images做解析和处理，接下来load images中调用 callloadmethods方法，遍历所有加载进来的Class，按继承层级依次调用Class的+load方法和其 Category的+load方法

整个事件由dyld主导，完成运行环境的初始化后，配合ImageLoader 将二进制文件按格式加载到内存，动态链接依赖库，并由runtime负责加载成objc 定义的结构，所有初始化工作结束后，dyld调用真正的main函数

这一步可做的优化有：
使用+initialize来代替+load
不要使用atribute((constructor)) 将方法显式标记为初始化器，而是让初始化方法调用时才执行。比如使用 dispatch_once()、pthread_once() 或 std::once()。也就是在第一次使用时才初始化，推迟了一部分工作耗时。也尽量不要用到C++的静态对象。

pre-main阶段具体优化:
1、删除无用代码（未被调用的静态变量、类和方法）
可以使用AppCode对工程进行扫描，删除无用代码
删减一些无用的静态变量
删减没有被调用或者已经废弃的方法

2、+load方法处理
+load()方法，用于在App启动执行一些操作，+load()方法在Initializers阶段被执行，但过多的+load()方法则会拖慢启动速度。 
分析+load()方法，看是否可以延迟到App冷启动后的某个时间节点。
initialize的重复调用问题，能用dispatch_once()来完成的，就尽量不要用到load方法

3、针对减少不必要的库
基本上一个公共库越大，类越多，启动时在pre-main阶段所需的时间也越多
项目中使用cocoapods并没有设置use_frameworks，所以pod管理的有源码的第三方库都是静态库的形式

4、合并功能类似的类和扩展(Category)
由于Category的实现原理，和ObjC的动态绑定有很强的关系，所以实际上类的扩展是比较占用启动时间的。尽量合并一些扩展，会对启动有一定的优化作用。
这里只是强调要合并一些在工程、架构上没有太大意义的扩展。

5、压缩资源图片
因为启动的时候大大小小的图片加载个十来二十个是很正常的，图片小了，IO操作量就小了，启动当然就会快了。

静态库：.a和.framework
动态库: .dylib和.framework
Bundle的概念，framework是一种特殊类型的Bundle，bunlde是一个包含多个子文件夹的文件夹。
在iOS上，Bundlue将相关联的文件(比如图片, Nibs，代码)编译成一个包文件。
程序将它当作一个单独文件来处理，你可以在不知道内部实现的情况下使用它。
而库需要一些其他资源：头文件，本地化文件，图片资源，文档和示例。我们可以将其打包成一个bunlde，这就是framework。

在Podfile中
默认使用静态库，即 # use_frameworks!（#是注释标示）
添加use_frameworks!表明Pod使用动态库, Pods/Products里都是动态库(.framework文件)
不添加use_frameworks!表明Pod使用静态库, Pods/Products里都是静态库(.a文件)

即使我们将资源文件（图片等）打包到frameworks里，Xcode仍然未能引用它们。通过embedding framework让我们可以访问这些资源文件
https://developer.apple.com/library/archive/technotes/tn2435/_index.html#//apple_ref/doc/uid/DTS40017543-CH1-EMBED_SECTION

Umbrella frameworks的定义: Umbrella frameworks add minor refinements to the standard framework structure, such as the ability to encompass other frameworks
umberllar framework的目的是 隐藏不同frameworks之间的复杂依赖关系。
它允许你将不同的frameworks合并成一个framework，输出部分头文件。为了构建一个umbrella framework，你必须包含umbrella header。
https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Concepts/FrameworkAnatomy.html#//apple_ref/doc/uid/20002253-99314

为了能够引入framework modular，我们必须引入 module map
framework module ModularFramework{
  module Modulel{
    header "File1.h"
  }
  module Module2{
    header "File2.h"
  }
}
随后，使用module
import ModularFramework.Module1
import ModularFramework.Module2

CocoaPods允许使用umbrella和modular frameworks。如果你引入了pods到你的项目里，在Target->YourApp->Build Settings找查找modulemap和umbrella可以看到它们的设置。

Q: Podfile使用静态库时出现报错[!] The following Swift pods cannot yet be integrated as static libraries:,如何解决？
A：pod install 时的错误信息提示我们应该使用use_modular_headers!来让整个项目支持静态库，或者对单个Pod使用:modular_headers => true

===============================================================================================
通过修改库的类型和Clang插桩找到启动所需符号，然后修改编译参数完成二进制文件的重新排布提升应用的启动速度的。
通过staticlib优化、二进制重排两项技术

1. 动态库转静态库

Pre-main时间的查看:
在系统执行应用程序的main函数并调用应用程序委托函数(applicationWillFinishLaunching)之前，会发生很多事情。
我们可以将DYLD_PRINT_STATISTICS环境变量添加到项目scheme中。

dylib loading time 动态加载程序查找并读取应用程序使用的依赖动态库。
每个库本身都可能有依赖项。虽然苹果系统框架的加载是高度优化的，但加载嵌入式框架可能会很耗时。为了加快动态库的加载速度，苹果建议您使用更少的动态库，或者考虑合并它们。
建议的目标是六个额外的(非系统)框架。