https://objccn.io/issues/

==================================LLVM
http://www.aosabook.org/en/llvm.html

==================================编译器
编译器有两个职责：把 Objective-C 代码转化成低级代码，以及对代码做分析，确保代码中没有任何明显的错误
Xcode 的默认编译器是 clang
clang 的功能是首先对 Objective-C 代码做分析检查，然后将其转换为低级的类汇编代码：LLVM Intermediate Representation(LLVM 中间表达码)
接着 LLVM 会执行相关指令将 LLVM IR 编译成目标平台上的本地字节码，这个过程的完成方式可以是即时编译 (Just-in-time)，或在编译的时候完成

LLVM 指令的一个好处就是可以在支持 LLVM 的任意平台上生成和运行 LLVM 指令。
例如，你写的一个 iOS app, 它可以自动的运行在两个完全不同的架构(Inter 和 ARM)上，LLVM 会根据不同的平台将 IR 码转换为对应的本地字节码

LLVM 的优点主要得益于它的三层式架构 -- 第一层支持多种语言作为输入(例如 C, ObjectiveC, C++ 和 Haskell)，第二层是一个共享式的优化器(对 LLVM IR 做优化处理)，第三层是许多不同的目标平台(例如 Intel, ARM 和 PowerPC)

 
在编译一个源文件时，编译器的处理过程分为几个阶段。要想查看编译 hello.m 源文件需要几个不同的阶段，我们可以让通过 clang 命令观察：
% clang -ccc-print-phases hello.m
0: input, "hello.m", objective-c
1: preprocessor, {0}, objective-c-cpp-output // 预处理程序
2: compiler, {1}, assembler// 编译程序
3: assembler, {2}, object// 汇编程序
4: linker, {3}, image//（目标代码） 连接器
5: bind-arch, "x86_64", {4}, image

-----------------------预处理:
每当编译源文件的时候，编译器首先做的是一些预处理工作。比如预处理器会处理源文件中的宏定义，将代码中的宏用其对应定义的具体内容进行替换

#import <Foundation/Foundation.h>
预处理器对这行代码的处理是用 Foundation.h 文件中的内容去替换这行代码，如果 Foundation.h 中也使用了类似的宏引入，则会按照同样的处理方式用各个宏对应的真正代码进行逐级替代

这也就是为什么主张头文件最好尽量少的去引入其他的类或库，因为引入的东西越多，编译器需要做的处理就越多
@class MyClass;
代替：
#import "MyClass.h"
这么写是告诉编译器 MyClass 是一个类，并且在 .m 实现文件中可以通过 import MyClass.h 的方式来使用它。

自定义宏:
#define MY_CONSTANT 4
在预处理过程中 MY_CONSTANT 都会被替换成 4

注意:
#define MAX(a,b) a > b ? a : b
int main() {
  int i = 200;
  printf("largest: %d\n", MAX(i++,100));
  printf("i: %d\n", i);
  return 0;
}
用 clang -E max.c 进行宏展开的预处理结果是如下所示：
int main() {
  int i = 200;
  printf("largest: %d\n", i++ > 100 ? i++ : 100);// 201
  printf("i: %d\n", i);// 202
  return 0;
}
针对本例这类情况，最好使用 static inline:
#include <stdio.h>
static const int MyConstant = 200;

static inline int max(int l, int r) {
   return l > r ? l : r;
}

int main() {
  int i = MyConstant;
  printf("largest: %d\n", max(i++,100));
  printf("i: %d\n", i);
  return 0;
}

这里定义的代码是内联的 (inlined)，所以它的效率和宏变量差不多，但是可靠性比宏定义要好许多
宏的最佳使用场景是日志输出，可以使用 __FILE__ 和 __LINE__ 和 assert 宏

-----------------------词法解析标记
预处理完成以后，每一个 .m 源文件里都有一堆的声明和定义。这些代码文本都会从 string 转化成特殊的标记流。

例如，下面是一段简单的 Objective-C hello word 程序：

int main() {
  NSLog(@"hello, %@", @"world");
  return 0;
}
利用 clang 命令 clang -Xclang -dump-tokens hello.m 来将上面代码的标记流导出：

int 'int'        [StartOfLine]  Loc=<hello.m:4:1>
identifier 'main'        [LeadingSpace] Loc=<hello.m:4:5>
l_paren '('             Loc=<hello.m:4:9>
r_paren ')'             Loc=<hello.m:4:10>
l_brace '{'      [LeadingSpace] Loc=<hello.m:4:12>
identifier 'NSLog'       [StartOfLine] [LeadingSpace]   Loc=<hello.m:5:3>
l_paren '('             Loc=<hello.m:5:8>
at '@'          Loc=<hello.m:5:9>
string_literal '"hello, %@"'            Loc=<hello.m:5:10>
comma ','               Loc=<hello.m:5:21>
at '@'   [LeadingSpace] Loc=<hello.m:5:23>
string_literal '"world"'                Loc=<hello.m:5:24>
r_paren ')'             Loc=<hello.m:5:31>
semi ';'                Loc=<hello.m:5:32>
return 'return'  [StartOfLine] [LeadingSpace]   Loc=<hello.m:6:3>
numeric_constant '0'     [LeadingSpace] Loc=<hello.m:6:10>
semi ';'                Loc=<hello.m:6:11>
r_brace '}'      [StartOfLine]  Loc=<hello.m:7:1>
eof ''          Loc=<hello.m:7:2>

每一个标记都包含了对应的源码内容和其在源码中的位置

-----------------------解析
之前生成的标记流将会被解析成一棵抽象语法树 (abstract syntax tree -- AST)

#import <Foundation/Foundation.h>

@interface World
- (void)hello;
@end

@implementation World
- (void)hello {
  NSLog(@"hello, world");
}
@end

int main() {
   World* world = [World new];
   [world hello];
}
当我们执行 clang 命令 clang -Xclang -ast-dump -fsyntax-only hello.m 之后，命令行中输出的结果如下所示：：

@interface World- (void) hello;
@end
@implementation World
- (void) hello (CompoundStmt 0x10372ded0 <hello.m:8:15, line:10:1>
  (CallExpr 0x10372dea0 <line:9:3, col:24> 'void'
    (ImplicitCastExpr 0x10372de88 <col:3> 'void (*)(NSString *, ...)' <FunctionToPointerDecay>
      (DeclRefExpr 0x10372ddd8 <col:3> 'void (NSString *, ...)' Function 0x1023510d0 'NSLog' 'void (NSString *, ...)'))
    (ObjCStringLiteral 0x10372de38 <col:9, col:10> 'NSString *'
      (StringLiteral 0x10372de00 <col:10> 'char [13]' lvalue "hello, world"))))


@end
int main() (CompoundStmt 0x10372e118 <hello.m:13:12, line:16:1>
  (DeclStmt 0x10372e090 <line:14:4, col:30>
    0x10372dfe0 "World *world =
      (ImplicitCastExpr 0x10372e078 <col:19, col:29> 'World *' <BitCast>
        (ObjCMessageExpr 0x10372e048 <col:19, col:29> 'id':'id' selector=new class='World'))")
  (ObjCMessageExpr 0x10372e0e8 <line:15:4, col:16> 'void' selector=hello
    (ImplicitCastExpr 0x10372e0d0 <col:5> 'World *' <LValueToRValue>
      (DeclRefExpr 0x10372e0a8 <col:5> 'World *' lvalue Var 0x10372dfe0 'world' 'World *'))))

在抽象语法树中的每个节点都标注了其对应源码中的位置

-----------------------静态分析
一旦编译器把源码生成了抽象语法树，编译器可以对这棵树做分析处理，以找出代码中的错误，
比如类型检查：即检查程序中是否有类型错误。例如：如果代码中给某个对象发送了一个消息，编译器会检查这个对象是否实现了这个消息（函数、方法）。此外，clang 对整个程序还做了其它更高级的一些分析，以确保程序没有错误

类型检查：
每当开发人员编写代码的时候，clang 都会帮忙检查错误。其中最常见的就是检查程序是否发送正确的消息给正确的对象，是否在正确的值上调用了正确的函数

一般会把类型分为两类：动态的和静态的。动态的在运行时做检查，静态的在编译时做检查

其他分析:
clang 在静态分析阶段，除了类型检查外，还会做许多其它一些分析。如果你把 clang 的代码仓库 clone 到本地，然后进入目录 lib/StaticAnalyzer/Checkers，你会看到所有静态检查内容。比如 ObjCUnusedIVarsChecker.cpp 是用来检查是否有定义了，但是从未使用过的变量。而 ObjCSelfInitChecker.cpp 则是检查在 你的初始化方法中中调用 self 之前，是否已经调用 [self initWith...] 或 [super init] 了。编译器还进行了一些其它的检查，例如在 lib/Sema/SemaExprObjC.cpp 的 2,534 行，有这样一句：

Diag(SelLoc, diag::warn_arc_perform_selector_leaks);
这个会生成严重错误的警告 “performSelector may cause a leak because its selector is unknown” 

-----------------------代码生成
clang 完成代码的标记，解析和分析后，接着就会生成 LLVM 代码。下面继续看看hello.c：

#include <stdio.h>

int main() {
  printf("hello world\n");
  return 0;
}
要把这段代码编译成 LLVM 字节码（绝大多数情况下是二进制码格式），我们可以执行下面的命令：

clang -O3 -emit-LLVM hello.c -c -o hello.bc
接着用另一个命令来查看刚刚生成的二进制文件：

llvm-dis < hello.bc | less
输出如下：

; ModuleID = '<stdin>'
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-apple-macosx10.8.0"

@str = private unnamed_addr constant [12 x i8] c"hello world\00"

; Function Attrs: nounwind ssp uwtable
define i32 @main() #0 {
  %puts = tail call i32 @puts(i8* getelementptr inbounds ([12 x i8]* @str, i64 0, i64 0))
  ret i32 0
}

; Function Attrs: nounwind
declare i32 @puts(i8* nocapture) #1

attributes #0 = { nounwind ssp uwtable }
attributes #1 = { nounwind }

在上面的代码中，可以看到 main 函数只有两行代码：一行输出string，另一行返回 0。

再换一个程序，拿 five.m 为例，对其做相同的编译，然后执行 LLVM-dis < five.bc | less:

#include <stdio.h>
#import <Foundation/Foundation.h>

int main() {
  NSLog(@"%@", [@5 description]);
  return 0;
}
抛开其他的不说，单看 main 函数：

define i32 @main() #0 {
  %1 = load %struct._class_t** @"\01L_OBJC_CLASSLIST_REFERENCES_$_", align 8
  %2 = load i8** @"\01L_OBJC_SELECTOR_REFERENCES_", align 8, !invariant.load !4
  %3 = bitcast %struct._class_t* %1 to i8*
  %4 = tail call %0* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to %0* (i8*, i8*, i32)*)(i8* %3, i8* %2, i32 5)
  %5 = load i8** @"\01L_OBJC_SELECTOR_REFERENCES_2", align 8, !invariant.load !4
  %6 = bitcast %0* %4 to i8*
  %7 = tail call %1* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to %1* (i8*, i8*)*)(i8* %6, i8* %5)
  tail call void (%1*, ...)* @NSLog(%1* bitcast (%struct.NSConstantString* @_unnamed_cfstring_ to %1*), %1* %7)
  ret i32 0
}
上面代码中最重要的是第 4 行，它创建了一个 NSNumber 对象。第 7 行，给这个 number 对象发送了一个 description 消息。第 8 行，将 description 消息返回的内容打印出来

==================================
xcode工程build之后一般会执行如下几个步骤：
预处理
语法和语义分析
生成代码和优化
汇编
链接

iOS编译采用Clang作为编译器前端，LLVM作为编译器后端