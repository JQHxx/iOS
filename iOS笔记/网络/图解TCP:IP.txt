包与流:

应用层在发送数据的时候，都是站在一个个包的视角，将包一个个发送出去，形成一个 stream，
接收端收到 stream 之后，再按照具体的协议切割还原成发送方所发送的包。
发送方每一次调用 send()，并不会在接收方有一次对应的 receive() 回调，
有可能发送方 send() 10 次，每次 10 个字节，但是接受方只有一次 receive() 回调，
一次将 100 个字节抛给应用层。receive() 收到的数据只能看做是一个 stream，
所以，这里有一个包转换为流，然后流再还原成包的过程。
HTTP 实现了这一过程，但 TCP 本身并不负责这一过程，当我们基于 TCP 或者其他传输层协议实现自己的通讯协议的时候，
需要自己来处理这一转换过程。

三种办法来做包与流之间的转换
办法一：特殊切割符来分割包
这种办法粗暴简单，我们使用一个特殊字符来作为包与包之间的分隔符，不过这个分隔符要特殊，特殊到几乎不出现在包的内容当中，否则会影响接收方切割包的过程。
这种做法的缺陷也是显而易见的，必须严格要求包体中不会出现该特殊字符，所以这种办法只能应用于非常特殊的场景。
办法二：每个包都是固定长度
这种办法也是粗暴简单，甚至不需要分隔符，每次接收方从 stream 中取出固定长度的字节，还原成一个包，
代码也比较简单，在 receive() 回调里，每次检查是否达到了固定的长度，是则取出固定长度还原，否则继续等待
这种做法的缺陷就更大了，会造成包体的浪费，无法适应不同大小的包。

办法三：自定义协议，支持可变长度的包
当我们需要描述可变长度的包时，需要定义一个 header 来详细描述包相关的信息，比如最简单的，记录包的长度
接收方在收到 NSData 之后，可以先读取 4 个字节的长度信息，还原成 int 值，再读取 int 值所记录的字节数，这些字节就是我们的包了
=========================================
WAN （Wide Area Network） 广域网
MAN （Metropolitan Area Network） 城域网：连接整个城市的网络
LAN （Local Area Network） 局域网

