内购商品一共有四种类型:
消耗型:可以购买多次，多次结果累加，并且在App内作为“货币”消耗。典型的是虚拟货币，用户先通过IAP购买虚拟货币，再消耗虚拟货币购买商品。
非消耗型:只能购买一次，可跨设备使用，业务场景较少。典型的是图书App中的一本电子书，或者游戏中的一个关卡。
无法被消耗的商品，比如一些教育型APP中的课程, 再比如一些赛车游戏中的赛道, 
这类商品需要在审核添加恢复购买按钮, 用于用户购买过后再误删除或其他原因卸载APP后的恢复流程, 否则提交审核会被拒绝
我们发现你们的app包含内购功能，却没有给用户提供一个“恢复购买”的按钮。用户可以使用“恢复购买”功能保持对已购买内容的访问。例如，当他们升级到新手机时，他们不会丢失在旧手机上购买的所有商品。
自动续期订阅:和时间相关的服务，在有效期内用户可享受服务，要到期的时候自动扣费。典型的是连续包月的会员。
非续期订阅:和时间相关的服务，但是不会自动扣费。典型的是一个月会员

恢复购买：
订阅型和非消耗型的商品才有恢复状态
app账户a 用appleid购买了vip，app账户b登录用同一个appleid恢复购买，后端会做处理。b为vip，a为普通用户

App 专用共享密钥：
App 专用共享密钥是用于接收此 App 自动续订订阅收据的唯一代码
官方文档说秘钥仅仅用在自动续订上面

//沙盒测试环境验证
#define SANDBOX     @"https://sandbox.itunes.apple.com/verifyReceipt"
//正式环境验证
#define AppStore    @"https://buy.itunes.apple.com/verifyReceipt"

续订: 
后续续费都是Apple自动完成的，一般在要过期的前24小时开始，苹果会尝试扣费，扣费成功的话 会在APP下次启动的时候主动推送给APP
沙盒情况:5次续订(一共6条收据)后自动取消
1月10日订阅的连续包月，1月15日从包月切换到了包年，那么在2月10日的时候会扣掉一年的钱

订阅后,每次成功续期,打开App后会走- (void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray<SKPaymentTransaction *> *)transactions回调方法,
因此启动就要监听[[SKPaymentQueue defaultQueue] addTransactionObserver:self];

lists the compressed duration times：
Actual duration	Test duration
1 week	3 minutes
1 month	5 minutes
2 months	10 minutes
3 months	15 minutes
6 months	30 minutes
1 year	1 hour



测试:
Apple有两套内购Server：sandbox和production。
只有从App Store上下载的才会走production环境，可以App审核通过后，用redeem码兑换来测试真金白银购买。
平时插线和testflight的包都是走sandbox。
想要在sandbox购买需要先在iTunes Connect中注册“沙箱技术测试员”，当然如果Apple Id在内部测试组里，也可以直接走sandbox购买

服务器验证：
/**
* 21000 App Store不能读取你提供的JSON对象
* 21002 receipt-data域的数据有问题
* 21003 receipt无法通过验证
* 21004 提供的shared secret不匹配你账号中的shared secret
* 21005 receipt服务器当前不可用
* 21006 receipt合法，但是订阅已过期。服务器接收到这个状态码时，receipt数据仍然会解码并一起发送
* 21007 receipt是Sandbox receipt，但却发送至生产系统的验证服务
* 21008 receipt是生产receipt，但却发送至Sandbox环境的验证服务
*/
Apple会返回以下四个数据给应用：
productIdentifier:cosmosbox.strikehero.gems60
state: Purchased
receipt: 
ewoJInNpZ25hdHVyZSIgPSAiQXF1M3JiR1grbmJMeGVvZS9VZGlMa3dQWVlBdkQr
VTE1L1NRL2Y0cGZlaFlBOWFaVGhSbTNMVXpHc25TUGd3aVBoMmsxSTVFaVpweGp6
aEZsS0JDVXBPeHEyWFk5N1lHUGUzMFo0cThMRllDZWJPeHFzWlJaUU01N2xtZFo0
bDN6eHNnaWpGemFiYkRXLzM4cm1EeXFTT0FSYzRES3dXTGFpc2EzYUY5d2JwbUFB
QURWekNDQTFNd2dnSTdvQU1DQVFJQ0NCdXA0K1BBaG0vTE1BMEdDU3FHU0liM0RR
RUJCUVVBTUg4eEN6QUpCZ05WQkFZVEFsVlRNUk13RVFZRFZRUUtEQXBCY0hCc1pT
//receipt省略几十行
transactionIdentifier: 1000000160385706 // 交易标识符

交易状态: state
Purchased	购买成功
Restored	恢复购买
Failed	失败
Deferred	等待确认，儿童模式需要询问家长同意

// debug:
// transaction.transactionIdentifier - transaction.original?.transactionIdentifier
// 3月
[D][Purchase] Transaction Purchased, 
Product Identifier: com.fvcorp.group.auto.m03.AJSPremium Optional("1000000640254989")  Optional("1000000632743590")
// 1月
[D][Purchase] Transaction Purchased, 
Product Identifier: com.fvcorp.group.auto.m1.AJSPremium Optional("1000000640254989")  Optional("1000000632743590")
// 1月续订
[D][Purchase] Transaction Purchased, 
Product Identifier: com.fvcorp.group.auto.m1.AJSPremium Optional("1000000640258620")  Optional("1000000632743590")

==========自动订阅： 
[[SKPaymentQueue defaultQueue] addTransactionObserver:self];
因为自动订阅类型，除了第一次购买行为是用户主动触发的。后续续费都是 Apple 自动完成的，一般在要过期的前 24 小时开始，苹果会尝试扣费，扣费成功的话会在 APP 下次启动的时候主动推送给 APP。
所以，APP 启动的时候一定要添加上面的那句话

###
tran.originalTransaction.transactionIdentifier,这个标识符是绑定该appleID的,可以和App server的用户系统绑定起来,之后会继续用到.
但是这么做一旦用户使用一个appleId给多个账户充值,就会出现一对多的情况,因此这么解决
首先如果订阅不取消,是不能再购买订阅的,iOS会提示已经购买了该订阅.
然后,如果取消了一个userid下的订阅,使用另一个userid购买订阅,后台在拿到original_transaction_id的时候,去数据
库查询有没有绑定了这个original_transaction_id的userid,有的话,删除绑定,这样就可以维持original_transaction_id和userid一对一的绑定,之后恢复订阅也会给这个新的userid恢复.
###

(凭证)是可以一直使用的,但是一直使用同一个(凭证),拿到的JSON里receipt -> in_app不会变化,latest_receipt_info会随着续期的期数而变化,并且会越来越多

func paymentQueue(_ queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction]) {
[D][Purchase] Transaction Purchased, 
Product Identifier: com.fvcorp.group.auto.m1.AJSPremium 
Optional("1000000632060487")  Optional("1000000623879269")
}

================验证字段的含义说明
https://developer.apple.com/library/archive/releasenotes/General/ValidateAppStoreReceipt/Chapters/ReceiptFields.html#//apple_ref/doc/uid/TP40010573-CH106-SW2

================已验证
购买产品，弹出输入密码，购买弹窗时，杀死app，下次打开app会走
func paymentQueue(_ queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction]) 的SKPaymentTransactionState.failed
因为杀死app时没finishTransaction(transaction)

============error
if let skError = transaction.error as? SKError {
}

取模运算：Modulus Operation
取余运算：Remainder Operation

=====================订阅变化后->苹果订阅服务器通知app服务器设置
https://help.apple.com/app-store-connect/#/dev0067a330b

https://developer.apple.com/documentation/storekit/in-app_purchase/subscriptions_and_offers/enabling_server-to-server_notifications?preferredLanguage=occ


=====================自动订阅归属的问题：
a. 苹果设计自动订阅的初衷是 ，订阅一个服务， 这个服务需要跟着 Apple ID走。
说白了，就是你A设备 用了Apple账号100001购买了，你换了B设备 用Apple账号100001登录app store，你同样能享受到服务。
国外的一些音乐类型、杂志报刊等用的比较多，游戏类的少，苹果自己的Apple music也有自动订阅（首创）。

b. 目前国内的一些应用或是游戏，希望的是自动订阅 关联的是 APP的 user id ，而不是Apple ID。
说白了，就是你购买了一个自动订阅服务，我不管你哪个apple id 支付的， 但是只能我一个 APP的 唯一用户可以享受服务。
这时候就需要APP自身做处理了，就是记住首次购买的transaction-id，并且绑定某个用户。
以后自动续费的话，都会有original-transaction-id，这个id 是第一次购买的transaction-id，根据这个服务器可以联系初始购买的服务。
有点描述偏了，当transaction-id绑定了用户，再次收到其它用户transaction-id请求时候，视情况处理了。（你也可以根据unique-vendor-identifier处理）

=====================是否需要实现restoreCompletedTransactions ？
答案：视需求吧。有少量文章说2014年起苹果审核严格了，必须要有一个按钮实现restoreCompletedTransactions。另外，我听百度一位同学说，爱奇艺2015年因为这个被拒过。但是，目前来看很多使用了订阅的应用或是游戏，并没有这个功能。
我是感觉，看需求了。订阅 是跟着 userid 唯一呢？ 还是跟着apple id 呢？在国内，一般都是前者。

=====================关于掉单的问题
答案：一定要在服务器校验完票据后，客户端收到服务器的反馈结果后再：
[[SKPaymentQueue defaultQueue] finishTransaction: transaction];


=====================自己的服务器怎么处理苹果的续订？
答：
首先用户第一次购买订阅，server需要把票据存储（最好把过期时间也记录一下，字段record_expires_date），苹果会通知我们的server的，其中notification_type 对应值为 INITIAL_BUY。

服务器需要做个定期（每天）检测，检测目前已有的所有订阅订单是否过期，如果发现过期了，就去苹果服务器验证receipt，其中苹果返回的latest_receipt_info 字段，会告诉最新的订阅订单情况，你可以校验expires-date与当前时间比较，判断该订阅有没有续订成功，并同时更新上述让记录的record_expires_date字段.

我们为什么做上述的处理？大家都知道苹果服务器会在订阅过期的前一天，对用户进行自动扣费，如果扣费成功了，苹果服务器并不会通知我们的服务器，这是重点。不过有个特例，如果苹果订阅过期前一天扣费失败了，苹果服务器后面几天还会尝试对用户自动扣费，如果后面扣费成功了（这时候用户实际状态是没有续订成功），苹果会通知我们的server的，其中notification_type 对应值为 RENEWAL,对于RENEWAL我们还是需要给用户更新为正在订阅的状态。

正式环境下，用户主动取消订阅，苹果会通知我们的server的，其中notification_type 对应值为 CANCEL，我们需要更新用户订阅的状态为取消。

总结，对于自动续订订阅，我们自己的服务器完全可以与apple server的交互应对用户的订阅状态，只需要确定客户端传来的用户第一次购买， user id 对应 original-transaction-id的关系。后面的续订，取消，变更套餐，完全不依赖于客户端传来的信息。
